---
title: 处理加权排序类型问题的一般套路
date: 2018-04-10 20:03:30
categories:
tags:
---

### 适用问题类型：

需要对n个元素(带有一定权重，比如花费，截止日期，持续时间等)进行排序以获得所要求的最优解

例如，你是一个小印刷社的老板，只有一台打印机。你每天都需要面对如下问题：每天早上客户们都会来找你下订单，你需要把这些订单排序依次去完成，而且要尽量让所有顾客满意。如何决定先完成谁的订单，后完成谁的订单呢？

这类问题就可以用到下面的套路了！



### 套路：

1. 首先考虑只存在两个元素的情况，比如A和B。那么我们可知，只有两种可能的排序情况，要么先A后B，要么先B后A。

2. 对于每种情况，写出其加权的数学表达式。

*举例：*

还是上面例子中的背景，假设顾客i的订单需要花费ti时间去完成。给出一个时间表(其实就是完成订单的顺序)，假设Ci表示i订单完成的时间，比如订单j是你今天第一个要完成的，Cj = tj，如果订单j是在i完成后所完成的，那么Cj = Ci + tj。同时每个顾客i都有一个权重(weight)wi，代表他们对你的小店的重要性。顾客i的满意程度取决于他订单的完成时间。因此，你希望排出一个时间表使得加权的完成时间尽量小，

设计一个算法可以给出最小化的sum(假设有n个订单，完成i订单所需时间ti，以及顾客i的权重wi都已给出)

*解：*

我们就可以套用上面的方法，先假设你的印刷店只有两个订单a和b，那么时间表无非就是先a后b或先b后a

当先a后b时，由上面的sum式子可以得出 Sab = wa·ta + wb(ta+tb) < wb·tb + wa(tb+ta) = Sba

消掉共有项，可以得出： wb·ta < wa·tb  ，

然后把带有a的项移到左边，带有b的项移到右边 ⇒  ta/wa < tb/wb

也就是说，上面这道例题，我们的算法是，把所有顾客的订单按照ti/wi的顺序从小到大排列，然后依次完成即可。



### 对该算法进行证明：

反证法：假设存在相邻2个元素没有按顺序放置(位置互换)，我们证明，当互换这两个元素后，其结果比原来更好。重复此步骤，
最终我们会得到一个排好序的序列，实际上其本质就是冒泡排序，其证明了排序好的序列别其他任何序列更高效(或者说，不比其他任何一种序列差)。因此，此算法是最佳方案。
